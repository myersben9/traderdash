// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.1
// source: PricingData.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "yahoo";

export interface PricingData {
  id: string;
  price: number;
  time: number;
  currency: string;
  exchange: string;
  quoteType: PricingData_QuoteType;
  marketHours: PricingData_MarketHoursType;
  changePercent: number;
  dayVolume: number;
  dayHigh: number;
  dayLow: number;
  change: number;
  shortName: string;
  expireDate: number;
  openPrice: number;
  previousClose: number;
  strikePrice: number;
  underlyingSymbol: string;
  openInterest: number;
  optionsType: PricingData_OptionType;
  miniOption: number;
  lastSize: number;
  bid: number;
  bidSize: number;
  ask: number;
  askSize: number;
  priceHint: number;
  vol24hr: number;
  volAllCurrencies: number;
  fromCurrency: string;
  lastMarket: string;
  circulatingSupply: number;
  marketcap: number;
}

export enum PricingData_QuoteType {
  NONE = 0,
  ALTSYMBOL = 5,
  HEARTBEAT = 7,
  EQUITY = 8,
  INDEX = 9,
  MUTUALFUND = 11,
  MONEYMARKET = 12,
  OPTION = 13,
  CURRENCY = 14,
  WARRANT = 15,
  BOND = 17,
  FUTURE = 18,
  ETF = 20,
  COMMODITY = 23,
  ECNQUOTE = 28,
  CRYPTOCURRENCY = 41,
  INDICATOR = 42,
  INDUSTRY = 1000,
  UNRECOGNIZED = -1,
}

export function pricingData_QuoteTypeFromJSON(object: any): PricingData_QuoteType {
  switch (object) {
    case 0:
    case "NONE":
      return PricingData_QuoteType.NONE;
    case 5:
    case "ALTSYMBOL":
      return PricingData_QuoteType.ALTSYMBOL;
    case 7:
    case "HEARTBEAT":
      return PricingData_QuoteType.HEARTBEAT;
    case 8:
    case "EQUITY":
      return PricingData_QuoteType.EQUITY;
    case 9:
    case "INDEX":
      return PricingData_QuoteType.INDEX;
    case 11:
    case "MUTUALFUND":
      return PricingData_QuoteType.MUTUALFUND;
    case 12:
    case "MONEYMARKET":
      return PricingData_QuoteType.MONEYMARKET;
    case 13:
    case "OPTION":
      return PricingData_QuoteType.OPTION;
    case 14:
    case "CURRENCY":
      return PricingData_QuoteType.CURRENCY;
    case 15:
    case "WARRANT":
      return PricingData_QuoteType.WARRANT;
    case 17:
    case "BOND":
      return PricingData_QuoteType.BOND;
    case 18:
    case "FUTURE":
      return PricingData_QuoteType.FUTURE;
    case 20:
    case "ETF":
      return PricingData_QuoteType.ETF;
    case 23:
    case "COMMODITY":
      return PricingData_QuoteType.COMMODITY;
    case 28:
    case "ECNQUOTE":
      return PricingData_QuoteType.ECNQUOTE;
    case 41:
    case "CRYPTOCURRENCY":
      return PricingData_QuoteType.CRYPTOCURRENCY;
    case 42:
    case "INDICATOR":
      return PricingData_QuoteType.INDICATOR;
    case 1000:
    case "INDUSTRY":
      return PricingData_QuoteType.INDUSTRY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PricingData_QuoteType.UNRECOGNIZED;
  }
}

export function pricingData_QuoteTypeToJSON(object: PricingData_QuoteType): string {
  switch (object) {
    case PricingData_QuoteType.NONE:
      return "NONE";
    case PricingData_QuoteType.ALTSYMBOL:
      return "ALTSYMBOL";
    case PricingData_QuoteType.HEARTBEAT:
      return "HEARTBEAT";
    case PricingData_QuoteType.EQUITY:
      return "EQUITY";
    case PricingData_QuoteType.INDEX:
      return "INDEX";
    case PricingData_QuoteType.MUTUALFUND:
      return "MUTUALFUND";
    case PricingData_QuoteType.MONEYMARKET:
      return "MONEYMARKET";
    case PricingData_QuoteType.OPTION:
      return "OPTION";
    case PricingData_QuoteType.CURRENCY:
      return "CURRENCY";
    case PricingData_QuoteType.WARRANT:
      return "WARRANT";
    case PricingData_QuoteType.BOND:
      return "BOND";
    case PricingData_QuoteType.FUTURE:
      return "FUTURE";
    case PricingData_QuoteType.ETF:
      return "ETF";
    case PricingData_QuoteType.COMMODITY:
      return "COMMODITY";
    case PricingData_QuoteType.ECNQUOTE:
      return "ECNQUOTE";
    case PricingData_QuoteType.CRYPTOCURRENCY:
      return "CRYPTOCURRENCY";
    case PricingData_QuoteType.INDICATOR:
      return "INDICATOR";
    case PricingData_QuoteType.INDUSTRY:
      return "INDUSTRY";
    case PricingData_QuoteType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PricingData_OptionType {
  CALL = 0,
  PUT = 1,
  UNRECOGNIZED = -1,
}

export function pricingData_OptionTypeFromJSON(object: any): PricingData_OptionType {
  switch (object) {
    case 0:
    case "CALL":
      return PricingData_OptionType.CALL;
    case 1:
    case "PUT":
      return PricingData_OptionType.PUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PricingData_OptionType.UNRECOGNIZED;
  }
}

export function pricingData_OptionTypeToJSON(object: PricingData_OptionType): string {
  switch (object) {
    case PricingData_OptionType.CALL:
      return "CALL";
    case PricingData_OptionType.PUT:
      return "PUT";
    case PricingData_OptionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PricingData_MarketHoursType {
  PRE_MARKET = 0,
  REGULAR_MARKET = 1,
  POST_MARKET = 2,
  EXTENDED_HOURS_MARKET = 3,
  UNRECOGNIZED = -1,
}

export function pricingData_MarketHoursTypeFromJSON(object: any): PricingData_MarketHoursType {
  switch (object) {
    case 0:
    case "PRE_MARKET":
      return PricingData_MarketHoursType.PRE_MARKET;
    case 1:
    case "REGULAR_MARKET":
      return PricingData_MarketHoursType.REGULAR_MARKET;
    case 2:
    case "POST_MARKET":
      return PricingData_MarketHoursType.POST_MARKET;
    case 3:
    case "EXTENDED_HOURS_MARKET":
      return PricingData_MarketHoursType.EXTENDED_HOURS_MARKET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PricingData_MarketHoursType.UNRECOGNIZED;
  }
}

export function pricingData_MarketHoursTypeToJSON(object: PricingData_MarketHoursType): string {
  switch (object) {
    case PricingData_MarketHoursType.PRE_MARKET:
      return "PRE_MARKET";
    case PricingData_MarketHoursType.REGULAR_MARKET:
      return "REGULAR_MARKET";
    case PricingData_MarketHoursType.POST_MARKET:
      return "POST_MARKET";
    case PricingData_MarketHoursType.EXTENDED_HOURS_MARKET:
      return "EXTENDED_HOURS_MARKET";
    case PricingData_MarketHoursType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBasePricingData(): PricingData {
  return {
    id: "",
    price: 0,
    time: 0,
    currency: "",
    exchange: "",
    quoteType: 0,
    marketHours: 0,
    changePercent: 0,
    dayVolume: 0,
    dayHigh: 0,
    dayLow: 0,
    change: 0,
    shortName: "",
    expireDate: 0,
    openPrice: 0,
    previousClose: 0,
    strikePrice: 0,
    underlyingSymbol: "",
    openInterest: 0,
    optionsType: 0,
    miniOption: 0,
    lastSize: 0,
    bid: 0,
    bidSize: 0,
    ask: 0,
    askSize: 0,
    priceHint: 0,
    vol24hr: 0,
    volAllCurrencies: 0,
    fromCurrency: "",
    lastMarket: "",
    circulatingSupply: 0,
    marketcap: 0,
  };
}

export const PricingData: MessageFns<PricingData> = {
  encode(message: PricingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.price !== 0) {
      writer.uint32(21).float(message.price);
    }
    if (message.time !== 0) {
      writer.uint32(24).sint64(message.time);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.exchange !== "") {
      writer.uint32(42).string(message.exchange);
    }
    if (message.quoteType !== 0) {
      writer.uint32(48).int32(message.quoteType);
    }
    if (message.marketHours !== 0) {
      writer.uint32(56).int32(message.marketHours);
    }
    if (message.changePercent !== 0) {
      writer.uint32(69).float(message.changePercent);
    }
    if (message.dayVolume !== 0) {
      writer.uint32(72).sint64(message.dayVolume);
    }
    if (message.dayHigh !== 0) {
      writer.uint32(85).float(message.dayHigh);
    }
    if (message.dayLow !== 0) {
      writer.uint32(93).float(message.dayLow);
    }
    if (message.change !== 0) {
      writer.uint32(101).float(message.change);
    }
    if (message.shortName !== "") {
      writer.uint32(106).string(message.shortName);
    }
    if (message.expireDate !== 0) {
      writer.uint32(112).sint64(message.expireDate);
    }
    if (message.openPrice !== 0) {
      writer.uint32(125).float(message.openPrice);
    }
    if (message.previousClose !== 0) {
      writer.uint32(133).float(message.previousClose);
    }
    if (message.strikePrice !== 0) {
      writer.uint32(141).float(message.strikePrice);
    }
    if (message.underlyingSymbol !== "") {
      writer.uint32(146).string(message.underlyingSymbol);
    }
    if (message.openInterest !== 0) {
      writer.uint32(152).sint64(message.openInterest);
    }
    if (message.optionsType !== 0) {
      writer.uint32(160).int32(message.optionsType);
    }
    if (message.miniOption !== 0) {
      writer.uint32(168).sint64(message.miniOption);
    }
    if (message.lastSize !== 0) {
      writer.uint32(176).sint64(message.lastSize);
    }
    if (message.bid !== 0) {
      writer.uint32(189).float(message.bid);
    }
    if (message.bidSize !== 0) {
      writer.uint32(192).sint64(message.bidSize);
    }
    if (message.ask !== 0) {
      writer.uint32(205).float(message.ask);
    }
    if (message.askSize !== 0) {
      writer.uint32(208).sint64(message.askSize);
    }
    if (message.priceHint !== 0) {
      writer.uint32(216).sint64(message.priceHint);
    }
    if (message.vol24hr !== 0) {
      writer.uint32(224).sint64(message.vol24hr);
    }
    if (message.volAllCurrencies !== 0) {
      writer.uint32(232).sint64(message.volAllCurrencies);
    }
    if (message.fromCurrency !== "") {
      writer.uint32(242).string(message.fromCurrency);
    }
    if (message.lastMarket !== "") {
      writer.uint32(250).string(message.lastMarket);
    }
    if (message.circulatingSupply !== 0) {
      writer.uint32(257).double(message.circulatingSupply);
    }
    if (message.marketcap !== 0) {
      writer.uint32(265).double(message.marketcap);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.time = longToNumber(reader.sint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.quoteType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.marketHours = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.changePercent = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.dayVolume = longToNumber(reader.sint64());
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.dayHigh = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.dayLow = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.change = reader.float();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.shortName = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.expireDate = longToNumber(reader.sint64());
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.openPrice = reader.float();
          continue;
        }
        case 16: {
          if (tag !== 133) {
            break;
          }

          message.previousClose = reader.float();
          continue;
        }
        case 17: {
          if (tag !== 141) {
            break;
          }

          message.strikePrice = reader.float();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.underlyingSymbol = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.openInterest = longToNumber(reader.sint64());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.optionsType = reader.int32() as any;
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.miniOption = longToNumber(reader.sint64());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.lastSize = longToNumber(reader.sint64());
          continue;
        }
        case 23: {
          if (tag !== 189) {
            break;
          }

          message.bid = reader.float();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.bidSize = longToNumber(reader.sint64());
          continue;
        }
        case 25: {
          if (tag !== 205) {
            break;
          }

          message.ask = reader.float();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.askSize = longToNumber(reader.sint64());
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.priceHint = longToNumber(reader.sint64());
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.vol24hr = longToNumber(reader.sint64());
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.volAllCurrencies = longToNumber(reader.sint64());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.fromCurrency = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.lastMarket = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 257) {
            break;
          }

          message.circulatingSupply = reader.double();
          continue;
        }
        case 33: {
          if (tag !== 265) {
            break;
          }

          message.marketcap = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      exchange: isSet(object.exchange) ? globalThis.String(object.exchange) : "",
      quoteType: isSet(object.quoteType) ? pricingData_QuoteTypeFromJSON(object.quoteType) : 0,
      marketHours: isSet(object.marketHours) ? pricingData_MarketHoursTypeFromJSON(object.marketHours) : 0,
      changePercent: isSet(object.changePercent) ? globalThis.Number(object.changePercent) : 0,
      dayVolume: isSet(object.dayVolume) ? globalThis.Number(object.dayVolume) : 0,
      dayHigh: isSet(object.dayHigh) ? globalThis.Number(object.dayHigh) : 0,
      dayLow: isSet(object.dayLow) ? globalThis.Number(object.dayLow) : 0,
      change: isSet(object.change) ? globalThis.Number(object.change) : 0,
      shortName: isSet(object.shortName) ? globalThis.String(object.shortName) : "",
      expireDate: isSet(object.expireDate) ? globalThis.Number(object.expireDate) : 0,
      openPrice: isSet(object.openPrice) ? globalThis.Number(object.openPrice) : 0,
      previousClose: isSet(object.previousClose) ? globalThis.Number(object.previousClose) : 0,
      strikePrice: isSet(object.strikePrice) ? globalThis.Number(object.strikePrice) : 0,
      underlyingSymbol: isSet(object.underlyingSymbol) ? globalThis.String(object.underlyingSymbol) : "",
      openInterest: isSet(object.openInterest) ? globalThis.Number(object.openInterest) : 0,
      optionsType: isSet(object.optionsType) ? pricingData_OptionTypeFromJSON(object.optionsType) : 0,
      miniOption: isSet(object.miniOption) ? globalThis.Number(object.miniOption) : 0,
      lastSize: isSet(object.lastSize) ? globalThis.Number(object.lastSize) : 0,
      bid: isSet(object.bid) ? globalThis.Number(object.bid) : 0,
      bidSize: isSet(object.bidSize) ? globalThis.Number(object.bidSize) : 0,
      ask: isSet(object.ask) ? globalThis.Number(object.ask) : 0,
      askSize: isSet(object.askSize) ? globalThis.Number(object.askSize) : 0,
      priceHint: isSet(object.priceHint) ? globalThis.Number(object.priceHint) : 0,
      vol24hr: isSet(object.vol24hr) ? globalThis.Number(object.vol24hr) : 0,
      volAllCurrencies: isSet(object.volAllCurrencies) ? globalThis.Number(object.volAllCurrencies) : 0,
      fromCurrency: isSet(object.fromCurrency) ? globalThis.String(object.fromCurrency) : "",
      lastMarket: isSet(object.lastMarket) ? globalThis.String(object.lastMarket) : "",
      circulatingSupply: isSet(object.circulatingSupply) ? globalThis.Number(object.circulatingSupply) : 0,
      marketcap: isSet(object.marketcap) ? globalThis.Number(object.marketcap) : 0,
    };
  },

  toJSON(message: PricingData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.quoteType !== 0) {
      obj.quoteType = pricingData_QuoteTypeToJSON(message.quoteType);
    }
    if (message.marketHours !== 0) {
      obj.marketHours = pricingData_MarketHoursTypeToJSON(message.marketHours);
    }
    if (message.changePercent !== 0) {
      obj.changePercent = message.changePercent;
    }
    if (message.dayVolume !== 0) {
      obj.dayVolume = Math.round(message.dayVolume);
    }
    if (message.dayHigh !== 0) {
      obj.dayHigh = message.dayHigh;
    }
    if (message.dayLow !== 0) {
      obj.dayLow = message.dayLow;
    }
    if (message.change !== 0) {
      obj.change = message.change;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.expireDate !== 0) {
      obj.expireDate = Math.round(message.expireDate);
    }
    if (message.openPrice !== 0) {
      obj.openPrice = message.openPrice;
    }
    if (message.previousClose !== 0) {
      obj.previousClose = message.previousClose;
    }
    if (message.strikePrice !== 0) {
      obj.strikePrice = message.strikePrice;
    }
    if (message.underlyingSymbol !== "") {
      obj.underlyingSymbol = message.underlyingSymbol;
    }
    if (message.openInterest !== 0) {
      obj.openInterest = Math.round(message.openInterest);
    }
    if (message.optionsType !== 0) {
      obj.optionsType = pricingData_OptionTypeToJSON(message.optionsType);
    }
    if (message.miniOption !== 0) {
      obj.miniOption = Math.round(message.miniOption);
    }
    if (message.lastSize !== 0) {
      obj.lastSize = Math.round(message.lastSize);
    }
    if (message.bid !== 0) {
      obj.bid = message.bid;
    }
    if (message.bidSize !== 0) {
      obj.bidSize = Math.round(message.bidSize);
    }
    if (message.ask !== 0) {
      obj.ask = message.ask;
    }
    if (message.askSize !== 0) {
      obj.askSize = Math.round(message.askSize);
    }
    if (message.priceHint !== 0) {
      obj.priceHint = Math.round(message.priceHint);
    }
    if (message.vol24hr !== 0) {
      obj.vol24hr = Math.round(message.vol24hr);
    }
    if (message.volAllCurrencies !== 0) {
      obj.volAllCurrencies = Math.round(message.volAllCurrencies);
    }
    if (message.fromCurrency !== "") {
      obj.fromCurrency = message.fromCurrency;
    }
    if (message.lastMarket !== "") {
      obj.lastMarket = message.lastMarket;
    }
    if (message.circulatingSupply !== 0) {
      obj.circulatingSupply = message.circulatingSupply;
    }
    if (message.marketcap !== 0) {
      obj.marketcap = message.marketcap;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PricingData>, I>>(base?: I): PricingData {
    return PricingData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PricingData>, I>>(object: I): PricingData {
    const message = createBasePricingData();
    message.id = object.id ?? "";
    message.price = object.price ?? 0;
    message.time = object.time ?? 0;
    message.currency = object.currency ?? "";
    message.exchange = object.exchange ?? "";
    message.quoteType = object.quoteType ?? 0;
    message.marketHours = object.marketHours ?? 0;
    message.changePercent = object.changePercent ?? 0;
    message.dayVolume = object.dayVolume ?? 0;
    message.dayHigh = object.dayHigh ?? 0;
    message.dayLow = object.dayLow ?? 0;
    message.change = object.change ?? 0;
    message.shortName = object.shortName ?? "";
    message.expireDate = object.expireDate ?? 0;
    message.openPrice = object.openPrice ?? 0;
    message.previousClose = object.previousClose ?? 0;
    message.strikePrice = object.strikePrice ?? 0;
    message.underlyingSymbol = object.underlyingSymbol ?? "";
    message.openInterest = object.openInterest ?? 0;
    message.optionsType = object.optionsType ?? 0;
    message.miniOption = object.miniOption ?? 0;
    message.lastSize = object.lastSize ?? 0;
    message.bid = object.bid ?? 0;
    message.bidSize = object.bidSize ?? 0;
    message.ask = object.ask ?? 0;
    message.askSize = object.askSize ?? 0;
    message.priceHint = object.priceHint ?? 0;
    message.vol24hr = object.vol24hr ?? 0;
    message.volAllCurrencies = object.volAllCurrencies ?? 0;
    message.fromCurrency = object.fromCurrency ?? "";
    message.lastMarket = object.lastMarket ?? "";
    message.circulatingSupply = object.circulatingSupply ?? 0;
    message.marketcap = object.marketcap ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
